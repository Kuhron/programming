# create stuff from the genome
# and this stuff will in turn do chemistry / ecology things

# take certain substrings and walk a path based on them
# 1 = go forward; 0 = turn left (starting from standard position)
# then get some numbers based on this path
# min/max x/y visited
# max/avg distance from origin
# these numbers are the chemical properties of the "proteins" made by the DNA substrings


import random
import numpy as np
import matplotlib.pyplot as plt
import functools

import RawVariation as rv
from OrganicChemical import OrganicChemical, plot_reaction_types, react_many_chemicals


def get_some_chemicals(dna):
    # don't get all substrings
    # start somewhere random, have bias toward shorter strings (exponential decay of how long you'll keep transcribing)
    expected_n = len(dna)
    should_transcribe = lambda: random.random() > 1 / expected_n
    expected_len = 10
    while should_transcribe():
        chemical = get_random_chemical(dna, expected_len)
        yield chemical


def get_random_chemical(dna, expected_substring_len):
    s = get_random_substring(dna, expected_substring_len)
    chemical = get_chemical_from_substring(s)
    return chemical


def get_random_substring(dna, expected_len):
    i = random.randrange(len(dna))
    s = []
    get_next_base = lambda: random.random() > 1 / expected_len
    while get_next_base():
        s.append(dna[i])
        i += 1
        if i >= len(dna):
            break
    return s


def get_all_chemicals(dna):
    return set(get_chemical_from_substring(s) for s in get_all_substrings(dna))


def get_all_substrings(dna):
    n = len(dna)
    for i in range(n):
        max_len = n - i
        for l in range(1, max_len + 1):
            yield tuple(dna[i : i + l])


def get_path_from_substring(arr):
    x,y = 0, 0
    res = [(x, y)]
    direction = 0
    for bit in arr:
        if bit == 0:
            direction = (direction + 90) % 360
        else:
            dx = 1 if direction == 0 else -1 if direction == 180 else 0
            dy = 1 if direction == 90 else -1 if direction == 270 else 0
            x += dx
            y += dy
            res.append((x,y))
    # print(f"arr {arr} gave path {res}")
    return res


def get_chemical_from_substring(arr):
    path = get_path_from_substring(arr)
    return OrganicChemical.from_path(path)


def simulate_chemical_reactions(chemicals):
    # pick two random molecules, so more common ones will bump into each other more often
    a,b = random.sample(chemicals, 2)
    # something about they will be attracted if their horizontalities are large and in opposite directions
    # similar with verticality, it acts like a different fundamental force but has same effect
    # larger mass makes the reaction take more energy
    raise NotImplementedError


def print_random_reactions():
    while True:
        dna0 = rv.get_dna(100)
        dna1 = rv.get_dna(100)
        chem0 = get_random_chemical(dna0, 10)
        chem1 = get_random_chemical(dna1, 10)
        chem2a = chem0.react_with(chem1)
        chem2b = chem1.react_with(chem0)
        assert chem2a == chem2b
        reaction = chem0.get_reaction_properties(chem1)
        if reaction["possible"]:
            print(f"  {chem0}\n+ {chem1}\n= {chem2a}\n")
            print("reaction:", reaction)
            input("check\n")
        else:
            pass # print(f"  {chem0}\n+ {chem1}\n  cannot react\n")



if __name__ == "__main__":
    dnas = [rv.get_dna(1000) for i in range(100)]

    # print_random_reactions()
    for dna in dnas:
        counts = {}
        for chemical in get_some_chemicals(dna):
            if chemical not in counts:
                counts[chemical] = 0
            counts[chemical] += 1
        print(f"\nDNA string:\n{rv.get_dna_str(dna)}\nproduced chemicals:")
        items = sorted(counts.items(), key=lambda kv: kv[1], reverse=True)
        for chemical, count in items:
            print(f"{count} units of {chemical}")

        chems = [chem for chem, count in items]
        plot_reaction_types(chems, show_magnitude_plots=False)
        react_many_chemicals(chems, counts, temperature=0)

# how should chemicals affect organisms? I think having them be the vector for ecological dynamics will be easiest
# basically the organisms interact through exchange of chemicals and then some can kill others or such by causing certain reactions
# so the chemicals that are around an organism should affect whether it can reproduce
# some could be mutagens, changing the rate of mutation in DNA transcription
# maybe some chemicals can exist in the environment but aren't made by biology (no DNA sequence can make that path)

# idea: the chemical generated by the substring "0" IS the nucleotide 0, simil for 1
# that way the nucleotides can interact with chemicals around them, so some things will be poisonous
# 
